<!DOCTYPE html>
<html lang=en>
<head>
<meta charset=utf-8 /> 
<meta name=viewport content="width=device-width, initial-scale=1"/>
<title>Box Line Text</title>
<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<style>
html,body {
  height:100%;
  width:100%;
  z-index:0;
  overflow:hidden;
}
section,p,arrow {
  position:absolute;
  margin:0;
  padding:0;
}
section,arrow {
  border:2px solid #777;
  border-radius:10px;
}
p {
  z-index:1;
  font:32px Noto Sans CJK JP, arial;
  padding:0 .5em;
  color:inherit;
  line-height:64px;
  outline:none;
}
arrow {
  border-width:0 4px 4px 0;
  border-radius:2px;
  padding:5px;
}
arrow.right { margin-top:-7px;  right:0px; transform:rotate(-45deg) }
arrow.left  { margin-top:-7px;  left:0px; transform:rotate(135deg) }
arrow.down  { margin-left:-7px; bottom:0px; transform:rotate(45deg) }
arrow.up    { margin-left:-7px; top:0px; transform:rotate(-135deg) }
[data-color="0"] { color: hsl(0  ,0% ,25%); }
[data-color="1"] { color: hsl(0  ,75%,25%); background-color: hsl(0,75%,90%); }
[data-color="2"] { color: hsl(120,75%,25%); background-color: hsl(120,75%,90%); }
[data-color="3"] { color: hsl(240,75%,25%); background-color: hsl(240,75%,90%); }
</style>
<script>
let snap = s => Math.min(Math.round(s / 64), 60) * 64 - 2 + 'px'

function createElement(p1, p2, temporary=true, content="", line_params=0) {
  document.querySelectorAll('body>*:empty').forEach(e => e.remove())

  let e = document.createElement('section')
  ;[e.style.width, e.style.height] = p1.map((s, i) => snap(Math.abs(s - p2[i])))

  let text = document.createElement('p')
  text.contentEditable = 'true'
  text.innerHTML = content.replace(/\n/g, '<br>')
  if (!temporary) e.append(text)

  if (!e.style.width && !e.style.height) e = text
  if (e.style.height && !e.style.width) {
    if (line_params & 0x01) addArrow(e, 'up')
    if (line_params & 0x02) addArrow(e, 'down')
  }
  if (e.style.width && !e.style.height) {
    text.style.top = '-66px'
    if (line_params & 0x01) addArrow(e, 'left')
    if (line_params & 0x02) addArrow(e, 'right')
  }

  ;[e.style.left, e.style.top] = p1.map((s, i) => snap(Math.min(s, p2[i])))
  document.body.append(e)
  text.focus()
}

function eraseElement(target) {
  erasing = true
  if (target != document.body) target.remove()
}

document.addEventListener('mousedown', e => {
  if (e.shiftKey || e.target.tagName != 'P') {
    e.preventDefault() // Prevents content selection while dragging

    if (e.shiftKey) eraseElement(e.target)
    else dragstart = [e.clientX, e.clientY]
  }
})

document.addEventListener('mousemove', e => {
  if (window.erasing) eraseElement(e.target)
  else if (window.dragstart) createElement([e.clientX, e.clientY], dragstart)
})

document.addEventListener('mouseup', e => {
  if (window.erasing || !dragstart) erasing = false
  else createElement(dragstart, [e.clientX, e.clientY], false)

  dragstart = false
  save()
})

function addArrow(el, dir) {
  let arrow = document.createElement('arrow')
  arrow.classList.add(dir)
  el.append(arrow)
}

document.addEventListener('keydown', function(e) {
  if (e.ctrlKey && e.key == 'z') {
    document.querySelector('body>:last-child').remove()
    e.preventDefault() // Prevents user agent text undo
  } else if (e.key.substring(0,5) == 'Arrow' && !e.target.textContent) {
    if ((!e.target.parentNode.style.height && 
        (e.key == 'ArrowLeft' || e.key == 'ArrowRight')) || 
        (!e.target.parentNode.style.width &&
        (e.key == 'ArrowUp' || e.key == 'ArrowDown'))) {
        addArrow(e.target.parentNode, e.key.substring(5).toLowerCase())
    } else {
      e.target.parentNode.dataset.color = (parseInt(e.target.parentNode.dataset.color || 0) + 1) % 4
    }
  }
})

function getTextContent(el) {
  // Convert <div> and <br> from HTML to newlines in plain text
  let html = el.innerHTML.replace(/(<div>|<br>)/g, "\n")
                         .replace(/<.*?>/g, "")
                         .replace(/\n$/, "")

  // Decode HTML entities
  var tmp = document.createElement("textarea");
  tmp.innerHTML = html
  return tmp.textContent
}

chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_?/:@.~!$&'()*+,;="
posToChar = x => chars[(parseInt(x) + 2) / 64 || 0]
charToPos = c => (chars.indexOf(c) < 64) ? chars.indexOf(c) * 64 - 2 : 0

function save() {
  location.hash = "#1" + Array.from(document.querySelectorAll("body>:not(:empty)")).map(e => {
    let arrows = e.querySelector('arrow') ? 
                  64 + !!e.querySelector('.left,.up') +
                  2 * !!e.querySelector('.right,.down') :
                  0
  
    return encodeURIComponent(
      posToChar(e.style.left) + posToChar(e.style.top) +
      (e.style.width ? posToChar(e.style.width) : chars[arrows]) + 
      (e.style.height ? posToChar(e.style.height) : chars[arrows]) +
      getTextContent(e)).replace(/%(3F|2F|3A|40|21|26|27|28|29|2A|2B|2C|3D)/g,c => decodeURIComponent(c)).replace(/%20/g, '+').replace(/%0A/g, '$')
  }).join(';')
}
document.addEventListener('keyup', e => {
  if (e) {
    // Grow height if the inner `p` has become taller than the box.
    if (e.target.parentNode.clientHeight && e.target.clientHeight > e.target.parentNode.clientHeight) {
      e.target.parentNode.style.height = snap(e.target.clientHeight)
    }
    // Grow width if the inner `p` has become wider than the box
    // This should only happen when individual words are wider than the box
    if (e.target.parentNode.clientWidth && e.target.clientWidth > e.target.parentNode.clientWidth) {
      e.target.parentNode.style.width = snap(e.target.clientWidth+64)
    }
  }
  save()
})

window.onload = () => {
  location.hash.substring(2).split(';').forEach(e => {
    e = decodeURIComponent(e.replace(/\$/g,'%0A').replace(/\+/g,' '))
    if (e) {
      createElement(
        [charToPos(e[0]), charToPos(e[1])],
        [charToPos(e[2]) + charToPos(e[0]), charToPos(e[3]) + charToPos(e[1])],
        false, e.substring(4), Math.max(0, chars.indexOf(e[2]) - 64) || Math.max(0, chars.indexOf(e[3]) - 64))
      }
  })
}

document.addEventListener('paste', e => e.preventDefault())
</script>
</head>
<body>
</body>
</html>